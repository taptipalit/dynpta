#include <malloc.h>
#define _GNU_SOURCE
#include <execinfo.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <dirent.h>
#include <inttypes.h>
#include <emmintrin.h> 
#include <immintrin.h>
#include <sanitizer/dfsan_interface.h>

uint64_t rbp, rsp;
uint64_t lastAddr __attribute__ ((aligned (16)));
int dirty __attribute__ ((aligned (16)));
char asm_str[100] __attribute__ ((aligned (16)));
char offset_str[2] __attribute__ ((aligned (16)));

long long enc = 0;
long long dec = 0;
long aesenccount, aesdeccount;

void encrypt_cache(void*);
void decrypt_cache(void*);
void encrypt_memory(void*);
void encrypt_memory(void*);

// The debug routines
void encrypt_debug(void*);
void decrypt_debug(void*);


#define BT_BUF_SIZE 100

void myfunc3(void)
{
	int j, nptrs;
	void *buffer[BT_BUF_SIZE];
	char **strings;

	nptrs = backtrace(buffer, BT_BUF_SIZE);
	printf("backtrace() returned %d addresses\n", nptrs);

	/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
	   would produce similar output to the following: */

	strings = backtrace_symbols(buffer, nptrs);
	if (strings == NULL) {
		perror("backtrace_symbols");
		exit(EXIT_FAILURE);
	}

	for (j = 0; j < nptrs; j++)
		printf("%s\n", strings[j]);

	free(strings);
}

void writeback_cache() {
	if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    lastAddr = 0x0;
    dirty = 0;
}

void getEncDecCount () {
    fprintf(stderr ,"Total No of Encryption is: %lld\n",enc);
    fprintf(stderr ,"Total No of Decryption is: %lld\n",dec);
}
void setEncryptedValueByte(void* ptr, uint8_t byte_arg) {
    //printf ("Encrypted_Byte: %p ",ptr);
    //printf ("Value to be encrypted : %d",byte_arg);
    //printf("and %" PRIu8 "\n", byte_arg);
    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;


    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {
        if (lastAddr > 0 && dirty) {

            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++; 
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }

    int dword_arg = byte_arg;
    dirty = 1;
    switch(offset) {
        case 0:
            asm("pinsrb $0, %0, %%xmm13  \n\t":: "r"(dword_arg) : );
            break;
        case 1:
            asm("pinsrb $1, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 2:
            asm("pinsrb $2, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 3:
            asm("pinsrb $3, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 4:
            asm("pinsrb $4, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 5:
            asm("pinsrb $5, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 6:
            asm("pinsrb $6, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 7:
            asm("pinsrb $7, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 8:
            asm("pinsrb $8, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 9:
            asm("pinsrb $9, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 10:
            asm("pinsrb $10, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 11:
            asm("pinsrb $11, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 12:
            asm("pinsrb $12, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 13:
            asm("pinsrb $13, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 14:
            asm("pinsrb $14, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 15:
            asm("pinsrb $15, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
    }
}

void setEncryptedValueWord(void* ptr, uint16_t word_arg) {
    //printf ("Encryted_Word: %p ",ptr); 
    //printf ("Value to be encrypted : %d ",word_arg);
    //printf("and %" PRIu16 "\n", word_arg);
    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {

            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }
    dirty = 1;
    offset = offset/2;

    int dword_arg = word_arg;
    switch(offset) {
        case 0:
            asm("pinsrw $0, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 1:
            asm("pinsrw $1, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 2:
            asm("pinsrw $2, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 3:
            asm("pinsrw $3, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 4:
            asm("pinsrw $4, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 5:
            asm("pinsrw $5, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 6:
            asm("pinsrw $6, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 7:
            asm("pinsrw $7, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
    }
}

void setEncryptedValueDWord(void* ptr, uint32_t dword_arg) {
    //printf ("Encryted_DWord: %p",ptr); 
    //printf ("Value to be encrypted : %d ",dword_arg);
    //printf("and %" PRIu32 "\n", dword_arg);
    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }
    dirty = 1;
    offset = offset/4;
    switch(offset) {
        case 0:
            asm("pinsrd $0, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 1:
            asm("pinsrd $1, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 2:
            asm("pinsrd $2, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 3:
            asm("pinsrd $3, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 4:
            asm("pinsrd $4, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 5:
            asm("pinsrd $5, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 6:
            asm("pinsrd $6, %0, %%xmm13 \n\t":: "r"(dword_arg) : );
            break;
        case 7:
            asm("pinsrd $7, %0, %%xmm13\n\t":: "r"(dword_arg) : );
            break;
    }
}

void setEncryptedValueQWord(void* ptr, uint64_t qword_arg) {
    //printf ("Encryted_QWord: %p",ptr); 
    //printf ("Value to be encrypted : %d ",qword_arg);
    //printf("and %" PRIu64 "\n", qword_arg);
    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }
    dirty = 1;
    offset = offset/8;
    switch(offset) {
        case 0:
            asm("pinsrq $0, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 1:
            asm("pinsrq $1, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 2:
            asm("pinsrq $2, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 3:
            asm("pinsrq $3, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 4:
            asm("pinsrq $4, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 5:
            asm("pinsrq $5, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 6:
            asm("pinsrq $6, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 7:
            asm("pinsrq $7, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
    }
}

void setEncryptedValueDouble(void* ptr, double qword_arg) {
    //printf ("Encryted_QWord: %p",ptr); 
    //printf ("Value to be encrypted : %d ",qword_arg);
    //printf("and %" PRIu64 "\n", qword_arg);
    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }
    dirty = 1;
    offset = offset/8;
    switch(offset) {
        case 0:
            asm("pinsrq $0, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
        case 1:
            asm("pinsrq $1, %0, %%xmm13 \n\t":: "r"(qword_arg) : );
            break;
    }
}
void setEncryptedValueVector (void* ptr, __m128i vec_arg) {
    uint64_t* vecArgPtr = (uint64_t*) &vec_arg;
    //printf ("Value to be encrypted : %016"PRIx64"%016"PRIx64" \n",vecArgPtr[0],vecArgPtr[1]);

    int offset = (uint64_t)ptr % 16;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);

            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;
        decrypt_cache((void*)aligned_ptr);
    }
    dirty = 1;
    asm("pinsrq $0, %0, %%xmm13 \n\t":: "r"(vecArgPtr[0]) : );
    asm("pinsrq $1, %0, %%xmm13 \n\t":: "r"(vecArgPtr[1]) : );
}

void setEncryptedValueVector4(void* ptr, __m256i vec_arg) {
    //printf ("Encryted_256Vec ptr: %p\n",ptr);
    uint64_t* vecArgPtr = (uint64_t*) &vec_arg;
    //printf ("Value to be encrypted : %016"PRIx64"%016"PRIx64"%016"PRIx64"%016"PRIx64"\n",vecArgPtr[0],vecArgPtr[1],vecArgPtr[2],vecArgPtr[3]);

    __m128i lower_128bit = _mm_set_epi64x(vecArgPtr[1] , vecArgPtr[0]);
    setEncryptedValueVector(ptr, lower_128bit);

    ptr = ptr + 16;
    //printf ("Encryted_256Vec ptr: %p\n",ptr);
    
    __m128i upper_128bit = _mm_set_epi64x(vecArgPtr[3] , vecArgPtr[2]);
    setEncryptedValueVector(ptr, upper_128bit);
}

uint8_t getDecryptedValueByte(void* ptr) {
    //printf ("Decryted_Byte: %p\n",ptr);
    int offset = (uint64_t)ptr % 16;
    register uint32_t result = 0;
    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;


    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {
        if (lastAddr > 0 && dirty) {

            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }
    switch(offset) {
        case 0:
            asm("pextrb $0, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 1:
            asm("pextrb $1, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 2:
            asm("pextrb $2, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 3:
            asm("pextrb $3, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 4:
            asm("pextrb $4, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 5:
            asm("pextrb $5, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 6:
            asm("pextrb $6, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 7:
            asm("pextrb $7, %%xmm13, %0 \n\t": "=r"(result) : );
            break;

        case 8:
            asm("pextrb $8, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 9:
            asm("pextrb $9, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 10:
            asm("pextrb $10, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 11:
            asm("pextrb $11, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 12:
            asm("pextrb $12, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 13:
            asm("pextrb $13, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 14:
            asm("pextrb $14, %%xmm13, %0 \n\t": "=r"(result) : );
            break;
        case 15:
            asm("pextrb $15, %%xmm13, %0 \n\t": "=r"(result) : );
            break;

    }
    //printf ("After decrypted : %d ",result);
    //printf("and %" PRIu8 "\n", result);
    return (uint8_t)result;
}

uint16_t getDecryptedValueWord(void* ptr) {
    //printf ("Decryted_Word: %p\n",ptr); 
    int offset = (uint64_t)ptr % 16;
    register uint32_t result = 0;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;


    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {
        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }
    offset = offset/2;
    switch(offset) {
        case 0:
            asm("pextrw $0, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 1:
            asm("pextrw $1, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 2:
            asm("pextrw $2, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 3:
            asm("pextrw $3, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 4:
            asm("pextrw $4, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 5:
            asm("pextrw $5, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 6:
            asm("pextrw $6, %%xmm13, %0\n\t": "=r"(result) : );
            break;
        case 7:
            asm("pextrw $7, %%xmm13, %0\n\t": "=r"(result) : );
            break;
    }
    //printf ("After decrypted : %d ",result);
    //printf("and %" PRIu16 "\n", result);
    return (uint16_t)result;
}

uint32_t getDecryptedValueDWord(void* ptr) {
    //printf ("Decryted_DWord: %p\n",ptr); 
    int offset = (uint64_t)ptr % 16;
    register uint32_t dword_result;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;


    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {


            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }
    offset = offset/4;
    switch(offset) {
        case 0:
            asm("pextrd $0, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 1:
            asm("pextrd $1, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 2:
            asm("pextrd $2, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 3:
            asm("pextrd $3, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 4:
            asm("pextrd $4, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 5:
            asm("pextrd $5, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 6:
            asm("pextrd $6, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
        case 7:
            asm("pextrd $7, %%xmm13, %0\n\t": "=r"(dword_result) : );
            break;
    }
    //printf ("After decrypted : %d ",dword_result);
    //printf("and %" PRIu32 "\n", dword_result);
    return dword_result;
}

double getDecryptedValueDouble(void* ptr) {
    int offset = (uint64_t)ptr % 16;
    register double qword_result;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }
    offset = offset/8;
    switch(offset) {
        case 0:
            asm("pextrq $0, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 1:
            asm("pextrq $1, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
    }
    //printf ("After decrypted : %d ",qword_result);
    //printf("and %" PRIu64 "\n", qword_result);
    return qword_result;
}

uint64_t getDecryptedValueQWord(void* ptr) {
    //printf ("Decryted_QWord: %p\n",ptr); 
    int offset = (uint64_t)ptr % 16;
    register uint64_t qword_result;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }
    offset = offset/8;
    switch(offset) {
        case 0:
            asm("pextrq $0, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 1:
            asm("pextrq $1, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 2:
            asm("pextrq $2, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 3:
            asm("pextrq $3, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 4:
            asm("pextrq $4, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 5:
            asm("pextrq $5, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 6:
            asm("pextrq $6, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
        case 7:
            asm("pextrq $7, %%xmm13, %0\n\t": "=r"(qword_result) : );
            break;
    }
    //printf ("After decrypted : %d ",qword_result);
    //printf("and %" PRIu64 "\n", qword_result);
    return qword_result;
}


__m128i getDecryptedValueVector(void* ptr) {
    
    //printf ("Decryted_QWord: %p\n",ptr); 
    int offset = (uint64_t)ptr % 16;
    register uint64_t lower_qword;
    register uint64_t upper_qword;

    uint64_t aligned_ptr = ((uint64_t) ptr) & 0xFFFFFFFFFFFFFFF0;

    // Align to 128 bit
    if (aligned_ptr != (uint64_t) lastAddr) {

        if (lastAddr > 0 && dirty) {
            encrypt_cache((void*)lastAddr);
            dirty = 0;
            //printf("Encryption %ld\n",enc++);
            enc++;
        }
        lastAddr = aligned_ptr;

        decrypt_cache((void*)aligned_ptr);
        //printf("Decryption %ld\n",dec++);
        dec++;
    }

    asm("pextrq $0, %%xmm13, %0\n\t": "=r"(lower_qword) : );
    asm("pextrq $1, %%xmm13, %0\n\t": "=r"(upper_qword) : );
    __m128i result = _mm_set_epi64x(upper_qword,lower_qword); 
    return result;
}


__m256i getDecryptedValueVector4(void* ptr) {
    //printf ("Decryted_ptr: %p\n",ptr); 
    __m128i lower_128bit = getDecryptedValueVector(ptr);
   
    ptr = ptr + 16; 
    //printf ("Decryted_ptr: %p\n",ptr); 
    __m128i upper_128bit = getDecryptedValueVector(ptr);

    __m256i result = _mm256_castps128_ps256(lower_128bit);
    result = _mm256_insertf128_ps(result, upper_128bit, 1);
    return result;
}

void encrypt_globals(char* ptr, long numBytes) {
    long numBlocks = (numBytes + (16 - 1)) / 16;
    //printf("address is %p and number of blocks is %d\n",(void*)ptr,numBlocks);
    for (int i = 0; i < numBlocks; i++) {
        encrypt_memory(ptr+(i*16));
    }
}

int libcallcount;
void encryptStringAfterLibCall(char *ptr) {
    //printf("%d\n", libcallcount++);

    if (ptr == 0x0) return;
    int i = 0;
    int j = 0;
    int break_next = 0;
    // Align the pointer so that the encryption succeeds
    ptr = (unsigned long) ptr & 0xFFFFFFFFFFFFFFF0;
    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    /*
       if (((unsigned long) ptr & 0xFFFFFFFFFFFFFFF0) != ptr) {
       fprintf(stderr, "Unaligned ptr\n");
       exit(-1);
       }
     */

    // The next block is the NULL character
    for (j = 0; j < 16; j++) {
        if (*(ptr+j) == '\0') {
            break_next = 1;
        }
    }

    while (1) {
        encrypt_memory(ptr);

        if (break_next) break;
        ptr+=16;
        // The next block is the NULL character
        for (j = 0; j < 16; j++) {
            if (*(ptr+j) == '\0') {
                break_next = 1;
            }
        }

    }
}

void decryptStringBeforeLibCall(char *ptr) {
    //printf("%d\n", libcallcount++);

    if (ptr == 0x0) return;
    int i = 0;
    int j = 0;
    int break_now = 0;
    // Align the pointer so that encryption succeeds
    ptr = (unsigned long) ptr & 0xFFFFFFFFFFFFFFF0;
    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    /*
       if (((unsigned long) ptr & 0xFFFFFFFFFFFFFFF0) != ptr) {
       fprintf(stderr, "Unaligned ptr\n");
       exit(-1);
       }
     */
    while (1) {
        decrypt_memory(ptr);
        // Did we see the NULL character already?
        for (j = 0; j < 16; j++) {
            if (*(ptr+j) == '\0') {
                break_now = 1;
            }
        }
        if (break_now) {
            break;
        }
        ptr+=16;
    }
}
void encryptStringPtrAfterLibCall(char **pptr) {
    char* ptr = *pptr;
    encryptStringAfterLibCall(ptr);
}

void encryptArrayForLibCall(char* ptr, int numBytes) {
//printf("%d\n", libcallcount++);

    if (ptr == 0x0) return;
    // Align the pointer
    char* ptrAligned = (unsigned long) ptr & 0xFFFFFFFFFFFFFFF0;
    // Now because we've aligned the pointer, we have to update the number of bytes
    numBytes += (ptr - ptrAligned);
    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    /*
    if (((unsigned long) ptr & 0xFFFFFFFFFFFFFFF0) != ptr) {
        fprintf(stderr, "Unaligned ptr\n");
        exit(-1);
    }
    */

    long numBlocks = (numBytes + (16-1))/16;
//    fprintf(stderr, "numblocks: %d\n", numBlocks);
    for (int i = 0; i < numBlocks; i++) {
        encrypt_memory(ptrAligned+(i*16));
    }
}
 
void encryptArrayPtrAfterLibCall(char **pptr, long size) {
    char* ptr = *pptr;
    encryptArrayForLibCall(ptr, size);
}

void decryptVaArgListBeforeLibCall(const char* format, va_list ap) {
    int va_count = 0;
    va_list aq;
    va_copy(aq, ap);
    char *s = NULL;
    while (*format) {
        if (*format == '%') {
            // assuming everything starting with % is a format specifier and has a corresponding vararg
            va_count++;
        }
        format++;
    }
    for (int i = 0; i < va_count; i++) {
        s = va_arg(aq, char *);
        decryptStringBeforeLibCall(s);
    }
    va_end(aq);
}

void encryptVaArgListAfterLibCall(const char* format, va_list ap) {
    va_list aq;
    va_copy(aq, ap);
    int va_count = 0;
    char *s = NULL;
    while (*format) {
        if (*format == '%') {
            // assuming everything starting with % is a format specifier and has a corresponding vararg
            va_count++;
        }
        format++;
    }
    for (int i = 0; i < va_count; i++) {
        s = va_arg(aq, char *);
        encryptStringAfterLibCall(s);
    }
    va_end(aq);
}

void decryptArrayForLibCall(char* ptr, int numBytes) {
//printf("%d\n", libcallcount++);
    if (ptr == 0x0) return;
    // Align the pointer
    char* ptrAligned = (unsigned long) ptr & 0xFFFFFFFFFFFFFFF0;
    // Now because we've aligned the pointer, we have to update the number of bytes
    numBytes += (ptr - ptrAligned);
    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    /*
    if (((unsigned long) ptr & 0xFFFFFFFFFFFFFFF0) != ptr) {
        fprintf(stderr, "Unaligned ptr\n");
        exit(-1);
    }
    */
    long numBlocks = (numBytes + (16-1))/16;
    for (int i = 0; i < numBlocks; i++) {
        decrypt_memory(ptrAligned+(i*16));
    }
}

void setLabelForContextSensitiveCalls(void* ptr){
    //printf( "Malloc ptr = %p for size = %d bytes.\n", ptr, malloc_usable_size(ptr));
    size_t noOfByte = malloc_usable_size(ptr);
    dfsan_set_label(1, ptr, noOfByte);
    //dividing noOfByte by 128 since we multiplied by 128 during memory allocation
    encryptArrayForLibCall(ptr, (noOfByte/128));
}

void aes_free(void* ptr) {
    //fprintf(stderr, "free Malloc ptr = %p for size = %d bytes.\n", ptr, malloc_usable_size(ptr));
    size_t noOfByte = malloc_usable_size(ptr);
    //dfsan_set_label(0, ptr, noOfByte);
    free(ptr);
}

void free_wrapper (void* ptr) {
    //printf( "Malloc ptr = %p for size = %d bytes.\n", ptr, malloc_usable_size(ptr));
    size_t noOfByte = malloc_usable_size(ptr);
    dfsan_set_label(0, ptr, noOfByte);
}

/*void aes_sodiumFree(void* ptr) {
    //printf( "Malloc ptr = %p for size = %d bytes.\n", ptr, malloc_usable_size(ptr));
    size_t noOfByte = malloc_usable_size(ptr);
    dfsan_set_label(0, ptr, noOfByte);
    sodium_free(ptr);
}*/

void* aes_freeWithBitcast(void* ptr) {
    //printf( "Malloc ptr = %p for size = %d bytes.\n", ptr, malloc_usable_size(ptr));
    size_t noOfByte = malloc_usable_size(ptr);
    //dfsan_set_label(0, ptr, noOfByte);
    free(ptr);
    return ptr;
}

void* aes_malloc(long size) {
    size = size*128; // hack to fix widening
    long roundedSize = -1;
    if (size % 16 == 0) {
        roundedSize = size;
    } else {
        roundedSize = size + 16;
    }
    
    //printf("AES_malloc size %ld\n",roundedSize);
    void* Ptr = aligned_alloc(16, roundedSize);
    //fprintf(stderr, "Malloc ptr = %p for size = %d bytes.\n", Ptr, roundedSize);
	//myfunc3();
    return Ptr;
}

/*void* aes_sodiumMalloc(long size) {
    size = size*16; // hack to fix widening
    long roundedSize = -1;
    if (size % 16 == 0) {
        roundedSize = size;
    } else {
        roundedSize = size + 16;
    }
    
    void* Ptr = sodium_malloc(roundedSize);
    return Ptr;
}*/

void* aes_calloc(long nmem, long elem_size) {
    elem_size = elem_size*16; // hack to fix widening
    long size = nmem*elem_size;
    long roundedSize = -1;
    if (size % 16 == 0) {
        roundedSize = size;
    } else {
        roundedSize = size + 16;
    }
    //printf("AES_calloc size %ld\n",roundedSize);
    void* Ptr = aligned_alloc(16, roundedSize);
    memset(Ptr, 0, roundedSize);
    //fprintf(stderr, "Calloc ptr = %p\n", Ptr);
//    printf("AES_calloc size %d\n",roundedSize);
    return Ptr;
}
void* aes_realloc(void* ptr, long size) {
    size = size*128; // hack to fix widening
    long roundedSize = -1;
    if (size % 16 == 0) {
        roundedSize = size;
    } else {
        roundedSize = size + 16;
    }
    ptr = realloc(ptr, roundedSize);
    return ptr;
}

/*
void dec_debug(void *ptr, int numBytes) {
    unsigned  long ptrLong = (unsigned long)(ptr);
    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    lastAddr = -1;
    dirty = 0;

    ptrLong &= 0xFFFFFFFFFFFFFFF0;

    if (ptrLong % 16 != 0) {
        fprintf(stderr, "Unaligned pointer passed\n");
        return;
    }

    int numBlocks = (numBytes + (16 - 1)) / 16;
    for (int i = 0; i < numBlocks; i++) {
        decrypt_debug((ptr+i*16));
    }
}

void enc_debug(void *ptr, int numBytes) {
    unsigned long ptrLong = (unsigned long)(ptr);

    if (lastAddr > 0 && dirty) {
        encrypt_cache((void*)lastAddr);
    }
    lastAddr = -1;
    dirty = 0;

    ptrLong &= 0xFFFFFFFFFFFFFFF0;

    int numBlocks = (numBytes + (16 - 1)) / 16;
    for (int i = 0; i < numBlocks; i++) {
        encrypt_debug((ptr+i*16));
    }
}
*/

struct dirent* clonereaddir(DIR *dir) {
   struct dirent* readDir = readdir(dir);
   struct dirent* clonedCopy = aes_malloc(sizeof(struct dirent));
   memcpy(clonedCopy, readDir, sizeof(struct dirent));
   return clonedCopy;
}

char* aes_strdup(const char* str) {
    char* dup = aes_malloc(strlen(str));
    strcpy(dup, str);
    return dup;
}

char* cloneenv(const char* name) {
    char* env = getenv(name);
    if (env) {
        return aes_strdup(getenv(name));
    } else {
        return NULL;
    }
}

int asprintf128(char **strp, const char *fmt, ...) {
    va_list arg;
    va_start(arg, fmt);
    int ret = vasprintf(strp, fmt, arg);
    // allocate a rounded-and-aligned buffer
    char * retptr = aes_calloc(strlen(*strp), sizeof(char));
    // Duplicate it
    strcpy(retptr, *strp);
    free(*strp); // Free the non-rounded-and-non-aligned version
    *strp = retptr; // Return pointer to the freshly minted string
    return ret;
}

int vasprintf128(char **strp, const char *fmt, va_list arg) {
    int ret = vasprintf(strp, fmt, arg);
    char * retptr = aes_calloc(strlen(*strp), sizeof(char));
    strcpy(retptr, *strp);
    free(*strp);
    *strp = retptr;
    return ret;
}

int count = 0;

void annotateStr(void* ptr) {
    int len = strlen(ptr);
    dfsan_set_label(1, ptr, len);
    encryptStringAfterLibCall(ptr);
}

void annotate(void* ptr) {
    fprintf(stderr, "annotating ptr at: %p\n", ptr);
    if (ptr == 0x0) return;
    size_t noOfByte = malloc_usable_size(ptr);
    noOfByte -=8; // some alignment stuff
    fprintf(stderr, "no of bytes: %d\n", noOfByte);
    dfsan_set_label(1, ptr, noOfByte/16);
    encryptArrayForLibCall(ptr, noOfByte/16);

}

/*
void annotate(void* ptr, int bytes) {
    if (bytes == 0) {
        annotateStr(ptr);
        return;
    }
    fprintf(stderr, "annotating ptr at: %p\n", ptr);
    if (ptr == 0x0) return;
    size_t noOfByte = malloc_usable_size(ptr);
    noOfByte -=8; // some alignment stuff
    fprintf(stderr, "no of bytes: %d\n", noOfByte);
    dfsan_set_label(1, ptr, noOfByte/16);
    encryptArrayForLibCall(ptr, noOfByte/16);
}
*/

void annotate1(void* ptr, int bytes) {
    fprintf(stderr, "annotating ptr at: %p\n", ptr);
    if (ptr == 0x0) return;
    dfsan_set_label(1, ptr, bytes);
    encryptArrayForLibCall(ptr, bytes);

}

//
// This file defines an implementation of Andersen's interprocedural alias
// analysis
//
// In pointer analysis terms, this is a subset-based, flow-insensitive,
// field-sensitive, and context-insensitive algorithm pointer algorithm.
//
// This algorithm is implemented as three stages:
//   1. Object identification.
//   2. Inclusion constraint identification.
//   3. Offline constraint graph optimization
//   4. Inclusion constraint solving.
//
// The object identification stage identifies all of the memory objects in the
// program, which includes globals, heap allocated objects, and stack allocated
// objects.
//
// The inclusion constraint identification stage finds all inclusion constraints
// in the program by scanning the program, looking for pointer assignments and
// other statements that effect the points-to graph.  For a statement like "A =
// B", this statement is processed to indicate that A can point to anything that
// B can point to.  Constraints can handle copies, loads, and stores, and
// address taking.
//
// The offline constraint graph optimization portion includes offline variable
// substitution algorithms intended to compute pointer and location
// equivalences.  Pointer equivalences are those pointers that will have the
// same points-to sets, and location equivalences are those variables that
// always appear together in points-to sets.  It also includes an offline
// cycle detection algorithm that allows cycles to be collapsed sooner
// during solving.
//
// The inclusion constraint solving phase iteratively propagates the inclusion
// constraints until a fixed point is reached.  This is an O(N^3) algorithm.
//
// Function constraints are handled as if they were structs with X fields.
// Thus, an access to argument X of function Y is an access to node index
// getNode(Y) + X.  This representation allows handling of indirect calls
// without any issues.  To wit, an indirect call Y(a,b) is equivalent to
// *(Y + 1) = a, *(Y + 2) = b.
// The return node for a function is always located at getNode(F) +
// CallReturnPos. The arguments start at getNode(F) + CallArgPos.
//

#ifndef TCFS_ANDERSEN_H
#define TCFS_ANDERSEN_H

#include "Constraint.h"
#include "NodeFactory.h"
#include "PtsSet.h"

#include "llvm/IR/DataLayout.h"
#include "llvm/IR/CallSite.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/Analysis/AliasAnalysis.h"

#include <vector>
#include <set>

class Andersen1
{
private:
	// A factory object that knows how to manage AndersNodes
	AndersNodeFactory nodeFactory;

	// Constraints - This vector contains a list of all of the constraints identified by the program.
	std::vector<AndersConstraint> constraints;

	// The Indirect Function vs Target map
	std::map<const llvm::Value*, std::vector<const llvm::Function*>> indirectFunctionTargetMap;

	// This is the points-to graph generated by the analysis
	std::map<NodeIndex, AndersPtsSet> ptsGraph;

	// The sanitized ptsToMap;
	std::map<llvm::Value*, std::set<llvm::Value*>> sanitizedPtsToMap;

	// The sanitized ptsFromMap;
	std::map<llvm::Value*, std::set<llvm::Value*>> sanitizedPtsFromMap;

	// The flag that tells the constraint collection to perform optimization based on data type
	bool applyComplexTypeOptimization;

	std::vector<llvm::Type*> SensitiveDataTypeList;

	// List of skipped functions
	std::vector<const llvm::Function*> SkippedFunctions;

	// The preprocessing phase that does some kind of pointer analysis
	void updateIndirectFunctionCalls(llvm::Module&);

	// The optimization based on sensitive data-types
	void findSensitiveTypes(llvm::Module&);

	// Check if a function uses sensitive data types
	bool usesSensitiveType(const llvm::Function&);

	// Three main phases
	void collectConstraints(const llvm::Module&, int);
	void optimizeConstraints();
	void solveConstraints();

	// Helper functions for constraint collection
	void collectConstraintsForGlobals(const llvm::Module&, int);
	void collectConstraintsForInstruction(const llvm::Instruction*, int);
	void addGlobalInitializerConstraints(NodeIndex, const llvm::Constant*);
	void addConstraintForCall(llvm::ImmutableCallSite cs);
	bool addConstraintForExternalLibrary(llvm::ImmutableCallSite cs, const llvm::Function* f);
	void addArgumentConstraintForCall(llvm::ImmutableCallSite cs, const llvm::Function* f);

	/*
	bool isSensitive(std::vector<const llvm::Value*> &L, const llvm::Value*);
	bool isaCPointer(llvm::Value*);
	void findSensitiveAnnotatedList(std::vector<const llvm::Value*> &, llvm::Module&);
	*/
	void dumpPtsToGraph(void);
	std::map<llvm::Value*, std::set<llvm::Value*>>& getSanitizedPtsToGraph(void);
	std::map<llvm::Value*, std::set<llvm::Value*>>& getSanitizedPtsFromGraph(void);

	// Helper functions for constraint optimization
	NodeIndex getRefNodeIndex(NodeIndex n) const;
	NodeIndex getAdrNodeIndex(NodeIndex n) const;

	// For debugging
	void dumpConstraint(const AndersConstraint&) const;
	void dumpConstraints() const;
	void dumpConstraintsPlainVanilla() const;
	void dumpPtsGraphPlainVanilla() const;

	//llvm::AliasResult interAlias(const llvm::Value*, const llvm::Value*);
public:
	static char ID;

	Andersen1(llvm::Module&);
	bool runOnModule(llvm::Module& M);
	void runPass(llvm::Module& M, int);

	// Given a llvm pointer v,
	// - Return false if the analysis doesn't know where v points to. In other words, the client must conservatively assume v can points to everything.
	// - Return true otherwise, and the points-to set of v is put into the second argument.
	bool getPointsToSet(const llvm::Value* v, std::vector<const llvm::Value*>& ptsSet) const;
	// Put all allocation sites (i.e. all memory objects identified by the analysis) into the first arugment
	void getAllAllocationSites(std::vector<const llvm::Value*>& allocSites) const;

	friend class AndersenAAResult;
	// The reset function
	void reset(void) {
		nodeFactory.reset();
		constraints.clear();
		ptsGraph.clear();
		sanitizedPtsToMap.clear();
		sanitizedPtsFromMap.clear();
	}


};

#endif
